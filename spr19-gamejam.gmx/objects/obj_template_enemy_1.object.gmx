<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// README
/*
* DESCRIPTION:
  This is a template for generic enemies that can move, rotate, and shoot.  Specific
  details of object behavior are determined by creation variables.  This template includes
  multiple options for attack and movement patterns.  New enemy variants can be made by
  mixing creation variables and attack and movement patterns.  This will work more as a
  parent object.

* ATTACK:

* MOVEMENT:

*/
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initialize Variables

// General
hp = 100;
movement_ai = 0;
attack_ai = 0;

// Attack
rate = 5; // how seconds between attacks
offset = 0; // how seconds to offset the attacks
stream = 120; // how many projectiles per attack
spread = 3; // in degrees
frames = -1 * offset * global.frames; // how many frames since last attack, move this after create

// Movement
rot_rate = 0; // for arbitrary rotation attack; in degrees per frame
sp = 12; // speed in pixels per frame, used for vertical and horizontal movement
speed = 12; // used for rotation based movement
direction = 0; // in case the enemy should have a fixed angle
image_angle = 0; // in case the enemy should have a fixed angle
// experimantal, consider adding a variable to specify instance
x_dist = 64; // minimum distance to keep from nearest entity of the same type
y_dist = 64; // same, but for the y axis
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Blending Mode

draw_set_blend_mode(bm_add);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Movement

if not(global.pause) {
  switch(movement_ai) {
    case 0: // static
      break;
      
    case 1: // moves from left to right
      if (obj_player.x - x &gt; sp - 1) and 
        not(collision_line(x, y, x + x_dist, y, obj_template_enemy_1, true, true))
        x += sp * global.scale_factor;
      else if (x - obj_player.x &gt; sp - 1) and
        not(collision_line(x, y, x - x_dist, y, obj_template_enemy_1, true, true))
        x -= sp * global.scale_factor;
      break;
  }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Attack

if not(global.pause) {
  frames++;
  
  // switch determines direction of attack
  switch(attack_ai) {
    case 0: // up and down attack
      if obj_player.y &lt; y {
        image_angle = 90;
        direction = 90;
      }
      else if obj_player.y &gt; y {
        image_angle = 270;
        direction = 270;
      }
      break;
      
    case 1: // left and right attack
      if obj_player.x &lt; x {
        image_angle = 180;
        direction = 180;
      }
      else if obj_player.x &gt; x {
        image_angle = 0;
        direction = 0;
      }
      break;
      
    case 2: // up, down, left, and right attack
      direction = point_direction(x, y, obj_player.x, obj_player.y);
      if (direction &lt; 45 and direction &gt;= 315)
        direction = 0;
      else if (direction &lt; 135 and direction &gt;= 45)
        direction = 90;
      else if (direction &lt; 225 and direction &gt;= 135)
        direction = 180;
      else
        direction = 270;
      break;
      
    case 3: // rotate toward the player
      direction = point_direction(x, y, obj_player.x, obj_player.y);
      break;
      
    case 4:
      direction += (30 / global.frames) * rot_rate;
      break; // rotate arbitrarily
  }
  
  // creates projectile objects
  if (frames == global.frames * rate) {
    for (i = -1 * floor(stream / 2); i &lt; ceil(stream / 2); i++) {
      bullet = instance_create(x, y, obj_triangle_projectile_1);
      bullet.direction = image_angle + (spread * i);
      bullet.image_angle = image_angle + (spread * i) + 90;
      }
    frames = 0;
  }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Sprite Control

image_angle = direction;
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
